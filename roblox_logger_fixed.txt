-- Function Spy для KRNL (Wrapper подход - БЕЗ хуков)
-- Модифицирует сам скрипт перед выполнением

local Logger = {
    logs = {},
    instance_counter = 0,
    instances = {}
}

-- Сериализация значений
function Logger:Serialize(value)
    local t = typeof(value)
    
    if t == "nil" then
        return "nil"
    elseif t == "boolean" or t == "number" then
        return tostring(value)
    elseif t == "string" then
        return string.format('"%s"', value:gsub('"', '\\"'):sub(1, 50))
    elseif t == "Instance" then
        return value:GetFullName()
    elseif t == "Color3" then
        return string.format("Color3.fromRGB(%d, %d, %d)", 
            math.floor(value.R * 255), 
            math.floor(value.G * 255), 
            math.floor(value.B * 255))
    elseif t == "UDim2" then
        return string.format("UDim2.new(%s, %s, %s, %s)", 
            value.X.Scale, value.X.Offset, 
            value.Y.Scale, value.Y.Offset)
    elseif t == "Vector3" then
        return string.format("Vector3.new(%s, %s, %s)", value.X, value.Y, value.Z)
    elseif t == "Vector2" then
        return string.format("Vector2.new(%s, %s)", value.X, value.Y)
    elseif t == "EnumItem" then
        return tostring(value)
    else
        return tostring(value)
    end
end

-- Обёртка для Instance.new
local function CreateInstanceWrapper()
    return function(className, parent)
        local inst = Instance.new(className, parent)
        
        local id = "_inst" .. Logger.instance_counter
        Logger.instance_counter = Logger.instance_counter + 1
        Logger.instances[inst] = id
        
        if parent then
            table.insert(Logger.logs, string.format('local %s = Instance.new("%s", %s)', 
                id, className, Logger.instances[parent] or "game.CoreGui"))
        else
            table.insert(Logger.logs, string.format('local %s = Instance.new("%s")', id, className))
        end
        
        -- Отслеживаем изменения свойств
        local tracked_props = {}
        task.spawn(function()
            while inst.Parent and #Logger.logs < 10000 do
                for _, prop in ipairs({"Name", "Size", "Position", "BackgroundColor3", "Text", "TextColor3", "Font", "TextSize", "Visible", "BackgroundTransparency", "ImageTransparency"}) do
                    local success, value = pcall(function() return inst[prop] end)
                    if success and value ~= tracked_props[prop] then
                        tracked_props[prop] = value
                        local val_str = Logger:Serialize(value)
                        table.insert(Logger.logs, string.format('%s.%s = %s', id, prop, val_str))
                    end
                end
                task.wait(0.05)
            end
        end)
        
        return inst
    end
end

-- Обёртка для Color3.fromRGB
local function CreateColor3Wrapper()
    return function(r, g, b)
        local color = Color3.fromRGB(r, g, b)
        local id = "_color" .. Logger.instance_counter
        Logger.instance_counter = Logger.instance_counter + 1
        Logger.instances[color] = id
        table.insert(Logger.logs, string.format('local %s = Color3.fromRGB(%d, %d, %d)', id, r, g, b))
        return color
    end
end

-- Инжектируем обёртки в окружение скрипта
function Logger:CreateEnvironment()
    local env = setmetatable({}, {__index = getfenv()})
    
    -- Переопределяем Instance
    env.Instance = setmetatable({}, {
        __index = function(t, k)
            if k == "new" then
                return CreateInstanceWrapper()
            end
            return Instance[k]
        end
    })
    
    -- Переопределяем Color3
    env.Color3 = setmetatable({}, {
        __index = function(t, k)
            if k == "fromRGB" then
                return CreateColor3Wrapper()
            elseif k == "new" then
                return function(r, g, b)
                    local color = Color3.new(r, g, b)
                    local id = "_color" .. Logger.instance_counter
                    Logger.instance_counter = Logger.instance_counter + 1
                    Logger.instances[color] = id
                    table.insert(Logger.logs, string.format('local %s = Color3.new(%s, %s, %s)', id, r, g, b))
                    return color
                end
            end
            return Color3[k]
        end
    })
    
    -- Переопределяем UDim2
    env.UDim2 = setmetatable({}, {
        __index = function(t, k)
            if k == "new" then
                return function(...)
                    return UDim2.new(...)
                end
            end
            return UDim2[k]
        end
    })
    
    -- Переопределяем game
    env.game = setmetatable({}, {
        __index = function(t, k)
            if k == "GetService" then
                return function(self, serviceName)
                    table.insert(Logger.logs, string.format('game:GetService("%s")', serviceName))
                    return game:GetService(serviceName)
                end
            end
            return game[k]
        end,
        __namecall = function(self, ...)
            local method = getnamecallmethod()
            if method == "GetService" then
                local args = {...}
                table.insert(Logger.logs, string.format('game:GetService("%s")', args[1]))
                return game:GetService(args[1])
            end
            return game[method](game, ...)
        end
    })
    
    -- Переопределяем task
    if task then
        env.task = setmetatable({}, {
            __index = function(t, k)
                if k == "wait" then
                    return function(time)
                        if time and time > 0 then
                            table.insert(Logger.logs, string.format('task.wait(%s)', time))
                        end
                        return task.wait(time)
                    end
                elseif k == "spawn" then
                    return function(func, ...)
                        table.insert(Logger.logs, 'task.spawn(function(...)')
                        return task.spawn(func, ...)
                    end
                end
                return task[k]
            end
        })
    end
    
    -- Переопределяем writefile
    if writefile then
        env.writefile = function(name, content)
            table.insert(Logger.logs, string.format('writefile("%s", ...)', name))
            return writefile(name, content)
        end
    end
    
    return env
end

-- Генерация отчёта
function Logger:GenerateReport()
    local report = {
        "-- Function Spy Output (KRNL Environment Wrapper)",
        "-- Total operations: " .. #self.logs,
        "",
        ""
    }
    
    for _, line in ipairs(self.logs) do
        table.insert(report, line)
    end
    
    return table.concat(report, "\n")
end

-- Главная функция
function SpyScript(code)
    print("\n===========================================")
    print("Function Spy - Starting...")
    print("===========================================\n")
    
    -- Очищаем
    Logger.logs = {}
    Logger.instances = {}
    Logger.instance_counter = 0
    
    -- Создаём окружение с обёртками
    local env = Logger:CreateEnvironment()
    
    print("[Spy] Executing with wrapped environment...")
    
    -- Загружаем и выполняем скрипт в нашем окружении
    local success, err = pcall(function()
        local func, load_err = loadstring(code)
        if not func then
            error("Failed to load script: " .. tostring(load_err))
        end
        setfenv(func, env)
        func()
    end)
    
    if not success then
        warn("[Spy] Script error: " .. tostring(err))
    end
    
    print("[Spy] Waiting for async operations...")
    task.wait(3)
    
    print("\n===========================================")
    print("Function Spy - Complete!")
    print("Total operations: " .. #Logger.logs)
    print("===========================================\n")
    
    local report = Logger:GenerateReport()
    
    -- Сохраняем
    if writefile then
        pcall(function()
            writefile("spy_output.lua", report)
            print("[Saved to: spy_output.lua]")
        end)
    end
    
    -- Показываем первые 30 строк
    print("\n--- First 30 operations ---")
    for i = 1, math.min(30, #Logger.logs) do
        print(Logger.logs[i])
    end
    if #Logger.logs > 30 then
        print("... (see spy_output.lua for full log)")
    end
    
    return report
end

-- Тест
function TestSpy()
    print("Running test...")
    
    local test_code = [[
        local sg = Instance.new("ScreenGui", game.CoreGui)
        sg.Name = "TestGUI"
        
        local frame = Instance.new("Frame", sg)
        frame.Size = UDim2.new(0, 200, 0, 100)
        frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        
        task.wait(0.5)
    ]]
    
    SpyScript(test_code)
end

return {
    SpyScript = SpyScript,
    TestSpy = TestSpy,
    Logger = Logger
}
