-- Aggressive Low-Level Function Spy для Luraph/Obfuscated Scripts
-- Работает на уровне metatable, перехватывает ВСЁ

local Logger = {
    logs = {},
    instances = {},
    instance_counter = 0,
    running = false
}

-- Генерация ID для Instance
function Logger:GetInstanceID(inst)
    if not self.instances[inst] then
        self.instance_counter = self.instance_counter + 1
        self.instances[inst] = "_inst" .. self.instance_counter
    end
    return self.instances[inst]
end

-- Безопасная сериализация
function Logger:Serialize(value)
    local t = type(value)
    
    if t == "nil" then
        return "nil"
    elseif t == "boolean" or t == "number" then
        return tostring(value)
    elseif t == "string" then
        if #value > 50 then
            return '"' .. value:sub(1, 50) .. '..."'
        end
        return '"' .. value:gsub('"', '\\"') .. '"'
    elseif t == "userdata" then
        -- Пытаемся получить информацию об Instance
        local success, result = pcall(function()
            if value.ClassName then
                return self:GetInstanceID(value)
            end
        end)
        if success and result then
            return result
        end
        
        -- Пробуем определить тип userdata
        local success2, typename = pcall(function()
            return typeof(value)
        end)
        
        if success2 then
            if typename == "Color3" then
                return string.format("Color3.fromRGB(%d, %d, %d)", 
                    math.floor(value.R * 255), 
                    math.floor(value.G * 255), 
                    math.floor(value.B * 255))
            elseif typename == "UDim2" then
                return string.format("UDim2.new(%s, %s, %s, %s)", 
                    value.X.Scale, value.X.Offset, 
                    value.Y.Scale, value.Y.Offset)
            elseif typename == "UDim" then
                return string.format("UDim.new(%s, %s)", value.Scale, value.Offset)
            elseif typename == "Vector2" then
                return string.format("Vector2.new(%s, %s)", value.X, value.Y)
            elseif typename == "Vector3" then
                return string.format("Vector3.new(%s, %s, %s)", value.X, value.Y, value.Z)
            elseif typename == "CFrame" then
                return "CFrame.new(...)"
            end
        end
        
        return "userdata"
    elseif t == "table" then
        -- Проверяем EnumItem
        local success, str = pcall(tostring, value)
        if success and str:match("^Enum%.") then
            return str
        end
        return "table"
    elseif t == "vector" then
        return string.format("Vector3.new(%s, %s, %s)", value.X, value.Y, value.Z)
    else
        local success, str = pcall(tostring, value)
        if success then
            return str
        end
        return t
    end
end

-- Логирование
function Logger:Log(code)
    -- Временно выключаем логирование чтобы избежать рекурсии
    self.running = false
    table.insert(self.logs, code)
    print("[SPY] " .. code)
    self.running = true
end

-- Главный хук - перехватываем ВСЁ
function Logger:Hook()
    self.running = true
    
    -- Получаем metatable
    local mt = getrawmetatable(game)
    local old_readonly = mt and mt.__metatable
    
    if not mt then
        warn("[Logger] Cannot get metatable!")
        return
    end
    
    -- Делаем metatable доступной для изменения
    setreadonly(mt, false)
    
    local original_namecall = mt.__namecall
    local original_newindex = mt.__newindex
    local original_index = mt.__index
    
    local logger = self
    
    -- Хук __namecall - перехватывает все вызовы методов
    mt.__namecall = function(self, ...)
        if not logger.running then
            return original_namecall(self, ...)
        end
        
        local method = getnamecallmethod()
        local args = {...}
        
        -- Особо важные методы
        if method == "GetService" and args[1] then
            logger:Log(string.format('game:GetService("%s")', args[1]))
        elseif method == "FindFirstChild" and args[1] then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('%s:FindFirstChild("%s")', id, args[1]))
        elseif method == "WaitForChild" and args[1] then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('%s:WaitForChild("%s")', id, args[1]))
        elseif method == "Connect" then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('%s:Connect(function(...)', id))
        elseif method == "Destroy" then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('%s:Destroy()', id))
        elseif method == "Clone" then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('%s:Clone()', id))
        end
        
        return original_namecall(self, ...)
    end
    
    -- Хук __newindex - перехватывает присвоение свойств
    mt.__newindex = function(self, property, value)
        -- Игнорируем внутренние объекты логгера
        if logger.running and not logger.instances[self] then
            local success = pcall(function()
                local id = logger:GetInstanceID(self)
                local val_str = logger:Serialize(value)
                logger:Log(string.format('%s.%s = %s', id, property, val_str))
            end)
        end
        
        return original_newindex(self, property, value)
    end
    
    -- Хук __index - перехватывает чтение свойств (опционально)
    -- Закомментировано т.к. может быть слишком много логов
    --[[
    mt.__index = function(self, property)
        local result = original_index(self, property)
        
        if logger.running and type(result) == "userdata" then
            local id = logger:GetInstanceID(self)
            logger:Log(string.format('-- %s.%s accessed', id, property))
        end
        
        return result
    end
    ]]
    
    setreadonly(mt, true)
    
    -- Хукаем Instance.new
    local old_instance_new = Instance.new
    Instance.new = function(className, parent)
        local inst = old_instance_new(className, parent)
        
        if logger.running then
            local id = logger:GetInstanceID(inst)
            if parent then
                local parent_id = logger:GetInstanceID(parent)
                logger:Log(string.format('local %s = Instance.new("%s", %s)', id, className, parent_id))
            else
                logger:Log(string.format('local %s = Instance.new("%s")', id, className))
            end
        end
        
        return inst
    end
    
    -- Хукаем Color3
    local old_color3_rgb = Color3.fromRGB
    Color3.fromRGB = function(r, g, b)
        local color = old_color3_rgb(r, g, b)
        
        if logger.running then
            local id = logger:GetInstanceID(color)
            logger:Log(string.format('local %s = Color3.fromRGB(%d, %d, %d)', id, r, g, b))
        end
        
        return color
    end
    
    -- Хукаем UDim2
    local old_udim2_new = UDim2.new
    UDim2.new = function(...)
        local udim = old_udim2_new(...)
        -- Не логируем UDim2 т.к. слишком много
        return udim
    end
    
    -- Хукаем глобальные функции
    local old_wait = task.wait or wait
    local new_wait = function(time)
        if logger.running and time then
            logger:Log(string.format('task.wait(%s)', time))
        end
        return old_wait(time)
    end
    
    if task then
        task.wait = new_wait
    else
        _G.wait = new_wait
    end
    
    -- task.spawn
    if task and task.spawn then
        local old_spawn = task.spawn
        task.spawn = function(func, ...)
            if logger.running then
                logger:Log('task.spawn(function(...)')
            end
            return old_spawn(func, ...)
        end
    end
    
    -- writefile
    if writefile then
        local old_writefile = writefile
        writefile = function(name, content)
            if logger.running then
                logger:Log(string.format('writefile("%s", ...)', name))
            end
            return old_writefile(name, content)
        end
    end
    
    print("[Logger] All hooks installed!")
end

-- Генерация отчёта
function Logger:GenerateReport()
    local report = {
        "-- Function Spy Output",
        "-- Total operations logged: " .. #self.logs,
        "",
        "-- Reconstructed code:",
        ""
    }
    
    for _, line in ipairs(self.logs) do
        table.insert(report, line)
    end
    
    return table.concat(report, "\n")
end

-- Главная функция
function SpyScript(code)
    print("\n===========================================")
    print("Function Spy - Starting...")
    print("===========================================\n")
    
    Logger:Hook()
    
    -- Запускаем целевой скрипт
    local success, err = pcall(function()
        local func = loadstring(code)
        if not func then
            error("Failed to load script")
        end
        func()
    end)
    
    if not success then
        warn("[Spy] Script error: " .. tostring(err))
    end
    
    -- Даём время на async операции
    task.wait(3)
    
    Logger.running = false
    
    print("\n===========================================")
    print("Function Spy - Complete!")
    print("Total operations: " .. #Logger.logs)
    print("===========================================\n")
    
    local report = Logger:GenerateReport()
    print(report)
    
    -- Сохраняем в файл
    if writefile then
        writefile("spy_output.lua", report)
        print("\n[Saved to: spy_output.lua]")
    end
    
    return report
end

-- Простой тест
function TestSpy()
    print("Running simple test...")
    
    Logger:Hook()
    
    -- Тестовый код
    local sg = Instance.new("ScreenGui", game.CoreGui)
    sg.Name = "TestGUI"
    
    local frame = Instance.new("Frame", sg)
    frame.Size = UDim2.new(0, 200, 0, 100)
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    
    task.wait(0.5)
    
    Logger.running = false
    
    local report = Logger:GenerateReport()
    print(report)
end

return {
    SpyScript = SpyScript,
    TestSpy = TestSpy,
    Logger = Logger
}
