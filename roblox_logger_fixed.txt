-- Function Spy для KRNL (без metatable хуков)
-- Перехватывает только основные функции

local Logger = {
    logs = {},
    instances = {},
    instance_counter = 0,
    running = false,
    original_funcs = {}
}

-- Генерация ID для Instance
function Logger:GetInstanceID(inst)
    if not self.instances[inst] then
        self.instance_counter = self.instance_counter + 1
        self.instances[inst] = "_inst" .. self.instance_counter
    end
    return self.instances[inst]
end

-- Безопасная сериализация
function Logger:Serialize(value)
    local t = type(value)
    
    if t == "nil" then
        return "nil"
    elseif t == "boolean" or t == "number" then
        return tostring(value)
    elseif t == "string" then
        if #value > 50 then
            return '"' .. value:sub(1, 50) .. '..."'
        end
        return '"' .. value:gsub('"', '\\"') .. '"'
    elseif t == "userdata" then
        -- Проверяем Instance
        local success, result = pcall(function()
            if value.ClassName then
                return self:GetInstanceID(value)
            end
        end)
        if success and result then
            return result
        end
        
        -- Проверяем другие типы
        local success2, typename = pcall(function()
            return typeof(value)
        end)
        
        if success2 then
            if typename == "Color3" then
                local success3, r, g, b = pcall(function()
                    return math.floor(value.R * 255), 
                           math.floor(value.G * 255), 
                           math.floor(value.B * 255)
                end)
                if success3 then
                    return string.format("Color3.fromRGB(%d, %d, %d)", r, g, b)
                end
            elseif typename == "UDim2" then
                local success3 = pcall(function()
                    return value.X.Scale, value.X.Offset, 
                           value.Y.Scale, value.Y.Offset
                end)
                if success3 then
                    return string.format("UDim2.new(%s, %s, %s, %s)", 
                        value.X.Scale, value.X.Offset, 
                        value.Y.Scale, value.Y.Offset)
                end
            elseif typename == "Vector3" then
                return string.format("Vector3.new(%s, %s, %s)", value.X, value.Y, value.Z)
            elseif typename == "Vector2" then
                return string.format("Vector2.new(%s, %s)", value.X, value.Y)
            end
        end
        
        return "userdata"
    elseif t == "table" then
        local success, str = pcall(tostring, value)
        if success and str:match("^Enum%.") then
            return str
        end
        return "{...}"
    else
        local success, str = pcall(tostring, value)
        if success then
            return str
        end
        return t
    end
end

-- Логирование
function Logger:Log(code)
    table.insert(self.logs, code)
end

-- Хук Instance.new
function Logger:HookInstanceNew()
    self.original_funcs.Instance_new = Instance.new
    local logger = self
    
    Instance.new = function(className, parent)
        local inst = logger.original_funcs.Instance_new(className, parent)
        
        if logger.running then
            local id = logger:GetInstanceID(inst)
            if parent then
                local parent_id = logger:GetInstanceID(parent)
                logger:Log(string.format('local %s = Instance.new("%s", %s)', id, className, parent_id))
            else
                logger:Log(string.format('local %s = Instance.new("%s")', id, className))
            end
            
            -- Хукаем присвоение свойств для этого instance
            logger:HookInstanceProperties(inst, id)
        end
        
        return inst
    end
end

-- Хук свойств конкретного Instance
function Logger:HookInstanceProperties(inst, id)
    local logger = self
    
    -- Список свойств для отслеживания
    local props = {
        "Name", "Parent", "Size", "Position", "BackgroundColor3",
        "Text", "TextColor3", "Font", "TextSize", "Visible",
        "Transparency", "BackgroundTransparency", "BorderSizePixel",
        "AnchorPoint", "Rotation", "ZIndex", "LayoutOrder",
        "ImageColor3", "ImageTransparency", "Image", "ResetOnSpawn"
    }
    
    -- Оборачиваем каждое свойство
    for _, prop in ipairs(props) do
        pcall(function()
            local original_value = inst[prop]
            local prop_set = false
            
            -- Создаём "ловушку" через hookfunction (если доступно)
            -- Иначе используем polling
            task.spawn(function()
                local last_value = original_value
                while logger.running and inst.Parent do
                    task.wait(0.1)
                    local success, current = pcall(function() return inst[prop] end)
                    if success and current ~= last_value and not prop_set then
                        local val_str = logger:Serialize(current)
                        logger:Log(string.format('%s.%s = %s', id, prop, val_str))
                        last_value = current
                    end
                end
            end)
        end)
    end
end

-- Хук Color3
function Logger:HookColor3()
    self.original_funcs.Color3_fromRGB = Color3.fromRGB
    local logger = self
    
    Color3.fromRGB = function(r, g, b)
        local color = logger.original_funcs.Color3_fromRGB(r, g, b)
        
        if logger.running then
            local id = logger:GetInstanceID(color)
            logger:Log(string.format('local %s = Color3.fromRGB(%d, %d, %d)', id, r, g, b))
        end
        
        return color
    end
end

-- Хук UDim2
function Logger:HookUDim2()
    self.original_funcs.UDim2_new = UDim2.new
    local logger = self
    
    UDim2.new = function(xScale, xOffset, yScale, yOffset)
        local udim = logger.original_funcs.UDim2_new(xScale, xOffset, yScale, yOffset)
        -- Не логируем UDim2 напрямую, только когда присваивается к Instance
        return udim
    end
end

-- Хук глобальных функций
function Logger:HookGlobals()
    -- task.wait
    if task and task.wait then
        self.original_funcs.task_wait = task.wait
        local logger = self
        
        task.wait = function(time)
            if logger.running and time and time > 0 then
                logger:Log(string.format('task.wait(%s)', time))
            end
            return logger.original_funcs.task_wait(time)
        end
    end
    
    -- task.spawn
    if task and task.spawn then
        self.original_funcs.task_spawn = task.spawn
        local logger = self
        
        task.spawn = function(func, ...)
            if logger.running then
                logger:Log('task.spawn(function(...)')
                logger:Log('    -- async function spawned')
                logger:Log('end)')
            end
            return logger.original_funcs.task_spawn(func, ...)
        end
    end
    
    -- writefile
    if writefile then
        self.original_funcs.writefile = writefile
        local logger = self
        
        _G.writefile = function(name, content)
            if logger.running then
                logger:Log(string.format('writefile("%s", ...)', name))
            end
            return logger.original_funcs.writefile(name, content)
        end
    end
end

-- Хук game:GetService (убран - не работает в KRNL)
function Logger:HookGetService()
    -- KRNL не поддерживает hookmetamethod
    -- Этот метод отключен
end

-- Установка всех хуков
function Logger:Hook()
    print("[Logger] Installing hooks...")
    
    self:HookInstanceNew()
    self:HookColor3()
    self:HookUDim2()
    self:HookGlobals()
    
    -- Пробуем хукнуть GetService
    pcall(function()
        self:HookGetService()
    end)
    
    print("[Logger] Hooks installed!")
end

-- Восстановление оригинальных функций
function Logger:Restore()
    if self.original_funcs.Instance_new then
        Instance.new = self.original_funcs.Instance_new
    end
    if self.original_funcs.Color3_fromRGB then
        Color3.fromRGB = self.original_funcs.Color3_fromRGB
    end
    if self.original_funcs.task_wait and task then
        task.wait = self.original_funcs.task_wait
    end
    if self.original_funcs.task_spawn and task then
        task.spawn = self.original_funcs.task_spawn
    end
    if self.original_funcs.writefile then
        _G.writefile = self.original_funcs.writefile
    end
end

-- Генерация отчёта
function Logger:GenerateReport()
    local report = {
        "-- Function Spy Output (KRNL Edition)",
        "-- Total operations logged: " .. #self.logs,
        "-- Note: Some operations may be missing due to executor limitations",
        "",
        ""
    }
    
    for _, line in ipairs(self.logs) do
        table.insert(report, line)
    end
    
    return table.concat(report, "\n")
end

-- Главная функция
function SpyScript(code)
    print("\n===========================================")
    print("Function Spy - Starting... (KRNL Edition)")
    print("===========================================\n")
    
    -- Очищаем предыдущие логи
    Logger.logs = {}
    Logger.instances = {}
    Logger.instance_counter = 0
    
    -- Устанавливаем хуки
    Logger:Hook()
    
    -- Включаем логирование
    Logger.running = true
    
    -- Запускаем целевой скрипт
    print("[Spy] Executing target script...")
    local success, err = pcall(function()
        local func, load_err = loadstring(code)
        if not func then
            error("Failed to load script: " .. tostring(load_err))
        end
        func()
    end)
    
    if not success then
        warn("[Spy] Script error: " .. tostring(err))
    end
    
    -- Даём время на async операции
    print("[Spy] Waiting for async operations...")
    task.wait(3)
    
    -- Выключаем логирование
    Logger.running = false
    
    -- Восстанавливаем функции
    Logger:Restore()
    
    print("\n===========================================")
    print("Function Spy - Complete!")
    print("Total operations: " .. #Logger.logs)
    print("===========================================\n")
    
    local report = Logger:GenerateReport()
    
    -- Сохраняем в файл
    if writefile then
        pcall(function()
            writefile("spy_output.lua", report)
            print("[Saved to: spy_output.lua]")
        end)
    end
    
    -- Выводим первые 20 строк
    print("\n--- First 20 operations ---")
    for i = 1, math.min(20, #Logger.logs) do
        print(Logger.logs[i])
    end
    if #Logger.logs > 20 then
        print("... (see spy_output.lua for full log)")
    end
    
    return report
end

-- Простой тест
function TestSpy()
    print("Running simple test...")
    
    Logger:Hook()
    Logger.running = true
    
    -- Тестовый код
    local sg = Instance.new("ScreenGui", game.CoreGui)
    sg.Name = "TestGUI"
    sg.ResetOnSpawn = false
    
    local frame = Instance.new("Frame", sg)
    frame.Size = UDim2.new(0, 200, 0, 100)
    frame.Position = UDim2.new(0.5, -100, 0.5, -50)
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    
    task.wait(1)
    
    Logger.running = false
    Logger:Restore()
    
    print("\n--- Test Results ---")
    for _, line in ipairs(Logger.logs) do
        print(line)
    end
end

return {
    SpyScript = SpyScript,
    TestSpy = TestSpy,
    Logger = Logger
}
